## 简介

### 版本控制系统的发展

**本地版本控制系统**

使用简单的数据库来记录文件的历次更新差异。例如RCS，RCS是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。

**集中化的版本控制系统(CVCS)**

如何让不同系统上的开发者协同工作？因此就有了CVCS。例如CVS等，它们都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或者提交更新。

**①优点**

每个人都可以在一定程度上看到项目中其他人正在做什么。管理员也可以轻松掌控每个开发者的权限。

**②缺点**

中央服务器单点故障时，无法协同工作，甚至当中心数据库所在的磁盘发生损坏，且又没有备份时，会丢失所有数据。

**分布式版本控制系统**

例如：Git 等。客户端不仅只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这样可以避免任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为任何每台机器上的每一次克隆操作，实际上都是对代码仓库的完整备份。

### Git 的起源

Linux 内核开源项目有很多的参与者，因此 Linux 内核的维护工作有很大一部分时间都花在了提交补丁和保存归档的繁琐事务上。2002年，Linux 项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年BitKeeper 同 Linux 内核开源社区的合作关系结束，开始收费。因此 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。

### Git 的特点

速度快，因此几乎所有操作都是在本地完成，不需要联网或者VPN

支持非线性开发模式，即可以有成千上万个并行开发的分支

完全分布式，不同机器上有相同的服务

可以高效管理超大规模的项目(速度和数据量并存)

Git 一般只添加数据，Git 执行的操作几乎都是可逆的

Git 保证完整性，所有的数据在存储前都计算校验和，然后以检验和来引用。因此不可能在 Git 不知情的情况下，更改任何文件内容或目录内容。Git 的检验和机制叫做 SHA-1 散列(hash，哈希)。这是一个由 40 个十六进制字符组成的字符串，基于 Git 中文件的内容或目录结构计算出来。

### 概念解释

#### 三种状态

**已修改**

表示修改了文件，但还没保存到数据库中。

**已暂存**

表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中

**已提交**

表示数据已经安全地保存在本地数据库中

#### 三个阶段

**工作区**

工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或者修改。

**暂存区**

暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做 ”索引“，不过一般说法还是叫 ”暂存区“。

**Git 目录**

Git 仓库目录是 Git 用来保存**项目的元数据和对象**数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 

#### 基本工作流程

在工作区中修改文件

将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区

提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录

## 常见操作命令以及作用

### 初次运行 Git 前的配置

配置用户信息

```
git config --global user.name "xxx"  // 设置用户名

git config --global user.email xxx   // 设置用户邮箱
```

查看配置

```
git config --list  // 查看所有配置

git config -user.name // 查看某一项配置
```

增删改配置

```
git config  --global --add user.name jianan //增
 
git config  --global --unset user.name //删
 
git config --global user.name jianan //改
```

### 创建本地仓库

两种方法

①将尚未进行版本控制的本地目录转化为 Git 仓库，打开想要转化为仓库的目录后执行下列命令

```
git init
```

②从其它机器克隆一个已存在的 Git 仓库

```
git clone <url>
```

### 文件状态

#### 各状态解释

工作目录下的文件有两种状态，**已跟踪** 或 **未跟踪**。已跟踪的文件是指已经纳入了版本控制的文件，在上一次快照中有它们的记录。简而言之，已跟踪文件就是 Git 已经知道的文件。**已跟踪**的状态有三种，**未修改**，**已修改**，**已放入暂存区**。

![状态转换图](D:\repository\git-learning\图片\状态转换图.png)

**未修改**：已经纳入版本控制的文件，但未修改。

**已修改**：已经纳入版本控制的文件，并且已发生修改。

出现在 `Changes not staged for commit` 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。

![添加到暂存区后修改状态](D:\repository\git-learning\图片\添加到暂存区后修改状态.jpg)

**已放入暂存区**：①已经纳入版本控制的文件，发生了修改并且将修改后的文件加到了暂存区中。②还未纳入版本控制的文件，将其纳入版本控制。

只要在 `Changes to be committed` 这行下面的，就说明是已暂存状态。

![添加到暂存区状态](D:\repository\git-learning\图片\添加到暂存区状态.jpg)

除上述状态之外都是**未跟踪**文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。未跟踪文件会出现在`Untracked files` 这行下面。

![未被追踪状态](D:\repository\git-learning\图片\未被追踪状态.jpg)

**注意**

①初次克隆某个仓库的时候，工作目录中的所有文件都是已跟踪文件，并处于未修改状态，因此 Git 刚刚检出了它们，而你尚未编辑过它们。

②执行 commit 命令后，文件从已放入暂存区编程未修改状态。

#### 各状态下的相关命令

##### 查看文件的状态

```
git status  // 当前工作区下所有文件的状态的详细信息

git status xxx  // 查看 xxx 文件的状态的详细信息

git status -s // 查看文件状态的简要信息
```

##### 添加到暂存区

```
git add xxx  // xxx表示文件名，将 xxx 添加到暂存区

git add -A  // 将工作区下所有的已跟踪和未跟踪文件的修改添加到暂存区
```

##### 查看具体修改

```
git diff // 查看已暂存的文件的修改部分，这条命令将比对文件已放入暂存区状态与已修改状态的差异

git diff --staged // 查看已暂存的将要添加到下次提交里的内容,这条命令将比对已暂存文件与最后一次提交的文件差异

git diff --cached // 与前一条命令作用相同
```

需要自己动手才能体会这三条命令的含义

##### 提交到本地库

提交暂存区中的内容，注意已修改但未暂存的文件不会提交到本地库

```
git commit // 使用该命令，会自动打开配置的文本编辑器，用来输入本次提交的说明，说明输入完成，保存退出编辑器后会自动完成本次提交操作

git commit -m"xxx"  // 在提交的同时完成提交说明的记录，xxx 表示本次提交的说明内容

git commit -a // 暂存所有追踪过的文件并且提交，即该操作等于先git add -A 再 git commit 
```

##### 删除文件

将纳入版本控制的文件删除，并且从工作区中删除

```
rm xxx // xxx 为文件名，第一步先正常删除某个文件

git rm xxx // 第二步执行该命令，记录此次移出文件的操作，下一次提交时该文件不再纳入版本管理

```

将文件从 Git 仓库中删除，即从暂存区域移除，但仍然希望保留在当前工作目录中

```
git rm -- cached xxx // 将xxx从暂存区中移出，变成未被追踪状态
```

`git rm` 命令后面可以列出文件或者目录的名字，也可以规则匹配。比如：

```
git rm log/\*.log  // 删除 log/ 目录下扩展名为 .log 的所有文件。

git rm \*~  // 删除所有名字以 ~ 结尾的文件
```

##### 修改文件名称

```
git mv file_from file_to
```

### 查看提交历史

```
git log  // 按时间先后顺序列出所有的提交，最近的更新排在最上面

git log -p // 显示每次提交所引入的差异 

git log -p -2 // 限制显示的日志数量，-2 表示只显示最近两次提交的日志

git log --stat // 显示每次提交的所有被修改过的文件中有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 并且在显示的日志最后还会有一个总结。

git log --pretty=format:"xxx"  // 自定义显示的日志格式
```

### 撤销操作

有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令来重新提交：

```
git commit --amend  // 如果自从上次提交以后，还未做任何修改，执行该命令可以修改上次提交的说明。如果自从上次提交以后，做了修改，会替换掉上次提交的内容。

git checkout -- xxx // 添加到暂存区发生修改后，回退到修改之前的状态
```

### 远程仓库相关命令

#### 添加远程仓库

```
git remote add <shortname> <url>  // 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写即 shortname 表示 url。
```

如果没有远程仓库，需要先创建远程仓库，再将远程仓库的信息添加到本地库。

#### 拉取远程仓库中的信息

```
git fetch <shortname>         // 拉取远程库<shortname>中有但当前库中没有的信息
```

执行完该命令后你将会拥有该远程仓库中所有分支的引用，可以随时合并查看

#### 推送到远程仓库

```
git push <remote> <branch>           // 将<branch>分支推送到<remote>远程库
```

只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。推送到 GitHub 时，可能需要输入 GitHub 的账号密码。当然也可以通过生成密钥，然后在仓库的设置里添加新的密钥。就不用每次push时，输入账号密码了。

#### 查看某个远程仓库

```
git remote                     // 查看远程仓库的简写

git remote -v                  // 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL

git remote show <remote>       // 查看某个远程仓库的信息
```

会列出远程仓库的 URL 与跟踪分支的信息

#### 远程仓库的移除和重命名

```
git remote rename <oldName> <newName>   // 修改远程仓库的简写名
```

```
git remote remove <shortname>  // 移出一个远程仓库
```

如果你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。

注：所谓的远程并不是指仓库在网络或者互联网上的其它位置，而只是表示它在别处。远程仓库也可以在你的主机上，在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送，拉取和抓取操作。

#### 克隆远程库

```
git clone <url>
```

当我们克隆了一个仓库时，通过 `git remote` 命令至少应该能看到 origin —— 这是 Git 给你克隆的仓库服务器的默认名字。

### 分支

#### 简介和作用

**分支操作中涉及到的对象**

假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和(SHA-1 哈希算法)，然后把当前版本的文件快照保存到 Git 仓库中，Git 使用 **数据对象**(blob object)来保存<font color="blue">文件快照</font>，最终将校验和加入到暂存区域等待提交。

当使用 `git commit` 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为**树对象**。树对象记录着<font color="blue">目录结构</font>和<font color="blue"> blob 对象索引</font>以及一个<font color="blue">提交对象(包含着指向前述树对象的指针和所有提交信息)</font>。

随后，在进行提交操作时，Git 会保存一个**提交对象**(commit object)。Git 保存的不是文件的变化或差异，而是一系列不同时刻的**快照**。因此该提交对象会包含<font color="blue">一个指向暂存内容快照的指针</font>，<font color="blue">作者的姓名和邮箱</font>，<font color="blue">提交时输入的信息</font>，<font color="blue">指向它的父对象的指针</font>以及<font color="blue">指向这个树对象（项目根目录）的指针</font>。当然首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。还包含指向这个树对象(项目根目录)的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。



**作用**

分支可以把你的工作从开发主线上分再进行离开来，以免影响主线的开发。

#### 创建分支

#### 合并分支

#### 处理冲突

## 忽略文件

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件的模式。

GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表， 你可以在 https://github.com/github/gitignore 找到它。

## 在服务器上安装Git

## 实现原理



